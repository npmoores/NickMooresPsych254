#df <- df[df$tar_name != "Bicycle",]
####################################################################################
#################### ANALYSIS: Aggregating Mean RT #################################
####################################################################################
####################################################################################
##Notes on aggregate(), since you always forget:####################################
##aggregate plays nicely with ggplot aggregate(output DV var ~ predictors in order##
##you want the columns to cycle thru, dataframe, statistical function) #############
##gives you a new df with the summary statistic you want (here it's the mean) ######
##I want to know what the mean is for each voice type, but I want to know for ######
##each trial type as well. Returns a dataframe consisting of the aggregated stats ##
##It gives you a summary stat (here means) for each combination of the predictor ###
##variables I give; it's basically creating a pivot table, right-most predictor var#
##is in blocks, left-most predictor var is cycling thru the fastest ################
####################################################################################
plot.style <- theme(panel.grid.major=element_blank(), legend.position="right", plot.title=element_text(face="bold", size=14), axis.title=element_text(size=12))
PD <- position_dodge(.9)
####Plot Reaction Time by Age
quartz()
rts <- aggregate(RT ~ has_comp + age, df, mean) #aggregate mean RTs by voice, trial type
rts.SEM <- aggregate(RT ~ has_comp + age, df, sem)
rts$SEM <- rts.SEM[,3]
qplot(age, RT, fill=has_comp, #plot bar graph with aggregated means dataframe
geom="bar",
position="dodge",
stat="identity",
data=rts) +
geom_errorbar(aes(ymin=RT-SEM, ymax=RT+SEM), colour="black", width=.2, position=PD) +
xlab("Subject Age") +
ylab("RT (mean)") +
ggtitle("Reaction Time by Trial Type and Age") +
scale_fill_discrete(name="Trial\nType",labels=c("Competitor","No Competitor")) +
plot.style
contrasts(vocabdata$sex)
library(reshape2)
library(ggplot2)
library(nlme)
library(lme4)
library(lmerTest)
vocabdata <- read.csv('http://www.stanford.edu/class/psych252/data/vocab0.csv')
head(vocabdata)
str(vocabdata)
summary(vocabdata)
colnames(vocabdata) <- c("subjectID","time","produced","sex")
vocabdata$sex <- factor(vocabdata$sex, labels=c("Male","Female"))
vocabdata$timef <- factor(vocabdata$time, labels=c("18mo","21mo","24mo","30mo"))
contrasts(vocabdata$sex)
contrasts(vocabdata$agef)
contrasts(vocabdata$timef)
head(vocabdata)
contrasts(vocabdata$timef) <- cbind(lin=c(-1,0,1),quad=c(-1,2,-1))
contrasts(vocabdata$timef)
contrasts(vocabdata$timef) <- cbind(lin=c(-1,0,0,1),quad=c(-2,2,2,-2))
contrasts(vocabdata$timef)
library(reshape2)
library(ggplot2)
library(nlme)
library(lme4)
library(lmerTest)
vocabdata <- read.csv('http://www.stanford.edu/class/psych252/data/vocab0.csv')
head(vocabdata)
str(vocabdata)
summary(vocabdata)
colnames(vocabdata) <- c("subjectID","time","produced","sex")
vocabdata$sex <- factor(vocabdata$sex, labels=c("Male","Female"))
vocabdata$timef <- factor(vocabdata$time, labels=c("18mo","21mo","24mo","30mo"))
sem <- function(x) {sd(x)/sqrt(length(x))}
ci95 <- function(x) {3.96*sem(x)}
interaction.plot(vocabdata$time, vocabdata$sex, vocabdata$produced, lty=c(1,2), lwd=2, ylab='Vocabulary Size', xlab='Child Age', trace.label='Gender')
contrasts(vocabdata$sex)
vocab_lm <- lm(produced ~ sex*poly(time,2), data = vocabdata)
summary(vocab_lm)
fvocab_lm <- lm(produced ~ sex*timef, data = vocabdata)
summary(fvocab_lm)
interaction.plot(vocabdata$time, vocabdata$sex, vocabdata$produced, lty=c(1,2), lwd=2, ylab='Vocabulary Size', xlab='Child Age', trace.label='Gender')
plot.style <- theme(panel.grid.major=element_blank(), legend.position="right", plot.title=element_text(face="bold", size=14), axis.title=element_text(size=12))
PD <- position_dodge(.9)
vocab.lmer.intonly <- lmer(produced ~ sex*poly(time,2) + (1 | subjectID), REML=FALSE, vocabdata)
summary(vocab.lmer.intonly)
logLik(vocab.lmer.intonly) #to get df for this lmer() model
MLdeviance.lmer <- c(deviance = -2*logLik(vocab.lmer.intonly))
df.lmer <- 8 #from logLik() output
deviance_diff <- MLdeviance.lm - MLdeviance.lmer
deviance_diff
df_diff <- df.lmer - df.lm
df_diff
pchisq(deviance_diff,df=df_diff,lower.tail=FALSE)
vocab_lm <- lm(produced ~ sex*poly(time,2), data = vocabdata)
summary(vocab_lm)
logLik(vocab_lm) #to get df for this lm() model
MLdeviance.lm <- c(deviance = -2*logLik(vocab_lm))
df.lm <- 7 #from logLik() output
vocab.lmer.intonly <- lmer(produced ~ sex*poly(time,2) + (1 | subjectID), REML=FALSE, vocabdata)
summary(vocab.lmer.intonly)
logLik(vocab.lmer.intonly) #to get df for this lmer() model
MLdeviance.lmer <- c(deviance = -2*logLik(vocab.lmer.intonly))
df.lmer <- 8 #from logLik() output
deviance_diff <- MLdeviance.lm - MLdeviance.lmer
deviance_diff
df_diff <- df.lmer - df.lm
df_diff
pchisq(deviance_diff,df=df_diff,lower.tail=FALSE)
MLdeviance.lmer
vocab.lmer.slopeint <- lmer(produced ~ sex*poly(time,2) + (1 + time | subjectID), REML=FALSE, vocabdata)
summary(vocab.lmer.slopeint)
logLik(vocab.lmer.slopeint) #to get df for this lmer() model
MLdeviance.slopeint <- c(deviance = -2*logLik(vocab.lmer.slopeint))
MLdeviance.slopeint
df.slopeint <- 10
deviance_diff <- MLdeviance.int - MLdeviance.slopeint
deviance_diff
df_diff <- df.slopeint - df.int
df_diff
pchisq(deviance_diff,df=df_diff,lower.tail=FALSE)
anova(vocab.lmer.int, vocab.lmer.slopeint) #verify that I get the same results
vocab_lm <- lm(produced ~ sex*poly(time,2), data = vocabdata)
summary(vocab_lm)
logLik(vocab_lm) #to get df for this lm() model
MLdeviance.lm <- c(deviance = -2*logLik(vocab_lm))
df.lm <- 7 #from logLik() output
vocab.lmer.int <- lmer(produced ~ sex*poly(time,2) + (1 | subjectID), REML=FALSE, vocabdata)
summary(vocab.lmer.int)
logLik(vocab.lmer.int) #to get df for this lmer() model
MLdeviance.int <- c(deviance = -2*logLik(vocab.lmer.int))
df.int <- 8 #from logLik() output
deviance_diff <- MLdeviance.lm - MLdeviance.int
deviance_diff
df_diff <- df.lmer - df.lm
df_diff
pchisq(deviance_diff,df=df_diff,lower.tail=FALSE)
vocab.lmer.slopeint <- lmer(produced ~ sex*poly(time,2) + (1 + time | subjectID), REML=FALSE, vocabdata)
summary(vocab.lmer.slopeint)
logLik(vocab.lmer.slopeint) #to get df for this lmer() model
MLdeviance.slopeint <- c(deviance = -2*logLik(vocab.lmer.slopeint))
MLdeviance.slopeint
df.slopeint <- 10
deviance_diff <- MLdeviance.int - MLdeviance.slopeint
deviance_diff
df_diff <- df.slopeint - df.int
df_diff
pchisq(deviance_diff,df=df_diff,lower.tail=FALSE)
anova(vocab.lmer.int, vocab.lmer.slopeint) #verify that I get the same results
couplesdata <- read.csv('http://www.stanford.edu/class/psych252/data/couples.csv')
head(couplesdata)
str(couplesdata)
summary(couplesdata)
couplesdata <- read.csv('http://www.stanford.edu/class/psych252/data/couples1.csv')
head(couplesdata)
str(couplesdata)
summary(couplesdata)
View(couplesdata)
colnames(couplesdata) <- c("age","education","income","training","quality","counsel","responded")
head(couplesdata)
str(couplesdata)
summary(couplesdata)
colnames(couplesdata) <- c("age","education","income","training","quality","counsel","selfconcept","responded")
head(couplesdata)
str(couplesdata)
summary(couplesdata)
View(couplesdata)
View(couplesdata)
couplesdata$age <- factor(vocabdata$age, labels=c("Young","Medium","Old"))
couplesdata$age <- factor(vocabdata$age, levels=c("Young","Medium","Old"))
couplesdata$agef <- factor(vocabdata$age, levels=c("Young","Medium","Old"))
couplesdata$age <- factor(couplesdata$age, labels=c("Young","Medium","Old"))
View(couplesdata)
couplesdata <- read.csv('http://www.stanford.edu/class/psych252/data/couples1.csv')
head(couplesdata)
str(couplesdata)
summary(couplesdata)
colnames(couplesdata) <- c("age","education","income","training","quality","counsel","selfconcept","responded")
couplesdata$agef <- factor(couplesdata$age, labels=c("Young","Medium","Old"))
View(couplesdata)
couplesdata$counsel <- factor(couplesdata$counsel, labels=c("No Counseling", "Counseling"))
library(corpcor)
?partial.r
library(car)
?partial.r
library(psych)
?partial.r
couplesdata <- read.csv('http://www.stanford.edu/class/psych252/data/couples1.csv')
colnames(couplesdata) <- c("age","education","income","training","quality","counsel","selfconcept","responded")
print(cor(couplesdata[-1]))
print(cor(couplesdata))
cor_matrix <- cor(couplesdata)
print(cor_matrix)
partial.r(cor_matrix,c(4,5),c(2))
?cor
cor_matrix <- cor(couplesdata, na.rm=TRUE)
print(cor_matrix)
partial.r(cor_matrix,c(4,5),c(2))
?lm
couplesdata <- read.csv('http://www.stanford.edu/class/psych252/data/couples1.csv')
colnames(couplesdata) <- c("age","education","income","training","quality","counsel","selfconcept","responded")
couplesdata$age.factor <- factor(couplesdata$age, labels=c("Young","Medium","Old"))
couplesdata$education.factor <- factor(couplesdata$education, labels=c("None","Some College","College"))
couplesdata$training.factor <- factor(couplesdata$training, labels=c("No_Training","Training"))
couplesdata$counsel.factor <- factor(couplesdata$counsel, labels=c("No_Counseling", "Counseling"))
couplesdata$responded <- factor(couplesdata$responded, labels=c("No_Response", "Responded"))
head(couplesdata)
str(couplesdata)
summary(couplesdata)
couples.glm <- glm(responded ~ age + education, data = couplesdata, family = binomial, na.action = na.omit)
summary(couples.glm)
couples.glm.factor <- glm(responded ~ age.factor + education.factor, data = couplesdata, family = binomial, na.action = na.omit)
logLik(couples.glm.factor) #to get df for this lm() model
MLdeviance.lm1 <- c(deviance = -2*logLik(couples.glm.factor))
df.lm1 <- 5 #from logLik() output
summary(couples.glm.factor)
couples.glm.full <- glm(responded ~ age.factor + education.factor + selfconcept, data = couplesdata, family = binomial, na.action = na.omit)
logLik(couples.glm.full) #to get df for this lmer() model
MLdeviance.lm2 <- c(deviance = -2*logLik(couples.glm.full))
df.lm2 <- 6 #from logLik() output
deviance_diff <- MLdeviance.lm1 - MLdeviance.lm2
deviance_diff
df_diff <- df.lm2 - df.lm1
df_diff
pchisq(deviance_diff,df=df_diff,lower.tail=FALSE)
summary(couples.glm.full)
anova(couples.glm.factor,couples.glm.full)
couples.lm.less <- lm(quality ~ training, data=couplesdata, na.action=na.omit)
summary(couples.lm.less)
couples.lm.full <- lm(quality ~ training + age + education, data=couplesdata,na.action=na.omit)
summary(couples.lm.full)
library(reshape2)
library(ggplot2)
library(nlme)
library(lme4)
library(lmerTest)
library(corpcor)
library(car)
library(psych)
vocabdata <- read.csv('http://www.stanford.edu/class/psych252/data/vocab0.csv')
head(vocabdata)
str(vocabdata)
summary(vocabdata)
colnames(vocabdata) <- c("subjectID","time","produced","sex")
vocabdata$sex <- factor(vocabdata$sex, labels=c("Male","Female"))
vocabdata$timef <- factor(vocabdata$time, labels=c("18mo","21mo","24mo","30mo"))
sem <- function(x) {sd(x)/sqrt(length(x))}
ci95 <- function(x) {3.96*sem(x)}
couplesdata <- read.csv('http://www.stanford.edu/class/psych252/data/couples1.csv')
colnames(couplesdata) <- c("age","education","income","training","quality","counsel","selfconcept","responded")
couplesdata$age.factor <- factor(couplesdata$age, labels=c("Young","Medium","Old"))
couplesdata$education.factor <- factor(couplesdata$education, labels=c("None","Some College","College"))
couplesdata$training.factor <- factor(couplesdata$training, labels=c("No_Training","Training"))
couplesdata$counsel.factor <- factor(couplesdata$counsel, labels=c("No_Counseling", "Counseling"))
couplesdata$responded <- factor(couplesdata$responded, labels=c("No_Response", "Responded"))
head(couplesdata)
str(couplesdata)
summary(couplesdata)
couples.glm <- glm(responded ~ age + education, data = couplesdata, family = binomial, na.action = na.omit)
summary(couples.glm)
couples.glm.factor <- glm(responded ~ age.factor + education.factor, data = couplesdata, family = binomial, na.action = na.omit)
logLik(couples.glm.factor) #to get df for this lm() model
MLdeviance.lm1 <- c(deviance = -2*logLik(couples.glm.factor))
df.lm1 <- 5 #from logLik() output
summary(couples.glm.factor)
couples.glm.full <- glm(responded ~ age.factor + education.factor + selfconcept, data = couplesdata, family = binomial, na.action = na.omit)
logLik(couples.glm.full) #to get df for this lmer() model
MLdeviance.lm2 <- c(deviance = -2*logLik(couples.glm.full))
df.lm2 <- 6 #from logLik() output
deviance_diff <- MLdeviance.lm1 - MLdeviance.lm2
deviance_diff
df_diff <- df.lm2 - df.lm1
df_diff
pchisq(deviance_diff,df=df_diff,lower.tail=FALSE)
summary(couples.glm.full)
anova(couples.glm.factor,couples.glm.full)
# R-code for principal component analysis (PCA)
###########################
# Example in 2 dimensions #
###########################
# generate some data:
a1 <- rnorm(100)
a2 <- rnorm(100)
x1 <- a1
x2 <- -sqrt(2/3)*a1 + sqrt(1/3)*a2
# standardize the data to have mean 0 and variance 1:
x1 <- (x1 - mean(x1))/sd(x1)
x2 <- (x2 - mean(x2))/sd(x2)
data <- data.frame(x1,x2)
# plot the data in a scatterplot:
#    pty="s" gives a square plotting region
#   (type '?par' to get the help file on plotting options)
plot(data, xlim=c(-4,4), ylim=c(-4,4), pty="s",
main="Scatterplot of the data")
# scatterplot where the numbers of the observations are indicated:
#    pch="" suppresses the plotting of points
plot(data, xlim=c(-4,4), ylim=c(-4,4), pty="s", pch="",
main="Scatterplot of the data")
text(data, labels=c(1:100))
# apply PCA
pca.res <- prcomp(data, retx=TRUE)
pca.res
summary(pca.res)
# detailed output of PCA:
pca.res$sdev     # standard deviations of the principal components
pca.res$rotation # matrix of variable loadings
pca.res$x        # if scores=TRUE, scores of the data on the
# principal components
rot <- pca.res$rotation
y1 <- rot[1,1]*x1 + rot[2,1]*x2
y2 <- rot[1,2]*x1 + rot[2,2]*x2
# note that this matches up with pca.res$x:
round(pca.res$x - cbind(y1,y2), 10)
# also:
round(pca.res$x - as.matrix(data) %*% pca.res$rotation, 10)
# plot rotated axes:
abline(0,rot[2,1]/rot[1,1], col="red", lwd=2)    # first PCA axis, largest variance
abline(0,rot[2,2]/rot[1,2], col="blue", lwd=2)   # second PCA axis, smallest variance
legend(2,0.5, c("PC.1","PC.2"), lty=c(1,1), col=c("red","blue"), lwd=c(2,2))
fit <- lm(x2 ~ x1)
abline(fit, lty=2)
summary(pca.res)
sd(y1)
sd(y2)
# total variance in original data:
total.var <- cov(data)[1,1] + cov(data)[2,2]
total.var
# proportional variance:
var(y1)/total.var
var(y2)/total.var
# check that correlation between y1 and y2 is zero:
round(cor(y1,y2), 10)
windows()  				# open new plotting window
plot(pca.res$x, pch="", xlim=c(-4,4), ylim=c(-4,4))
text(pca.res$x, labels=c(1:100))
abline(h=0, col="red", lwd=2)
abline(v=0, col="blue", lwd=2)
if (rot[1,1]<0) rot[,1] <- rot[,1]*-1
if (rot[1,2]<0) rot[,2] <- rot[,2]*-1
rot
y1 <- rot[1,1]*x1 + rot[2,1]*x2
y2 <- rot[1,2]*x1 + rot[2,2]*x2
windows()
plot(y1,y2, pch="", xlim=c(-4,4), ylim=c(-4,4))
text(y1,y2, labels=c(1:100))
abline(h=0, col="red", lwd=2)
abline(v=0, col="blue", lwd=2)
# compare to biplot with scale=0:
windows()
biplot(pca.res, scale=0, xlim=c(-4,4), ylim=c(-4,4))
# default biplot is similar, but axes are scaled differently:
windows()
biplot(pca.res)
bumpus <- read.table("http://www.ndsu.nodak.edu/ndsu/doetkott/introsas/rawdata/bumpus.html",
skip=20, nrows=49,
col.names=c("id","total","alar","head","humerus","sternum"))
bumpus <- bumpus[,-1]
boxplot(bumpus, main="Boxplot of Bumpus' data")
# we first standardize the data:
bumpus.scaled <- data.frame( apply(bumpus,2,scale) )
boxplot(bumpus.scaled, main="Boxplot of standardized Bumpus' data")
pca.res <- prcomp(bumpus.scaled, retx=TRUE)
pca.res
pca.res$x[,1:2]
plot(pca.res$x[,1:2], pch="", main="PC.1 and PC.2 for Bumpus' data (blue=survived, red=died)")
text(pca.res$x[,1:2], labels=c(1:49), col=c(rep("blue",21),rep("red",28)))
abline(v=0, lty=2)
abline(h=0, lty=2)
# compare to segment plot:
windows()
palette(rainbow(12, s = 0.6, v = 0.75))
stars(bumpus, labels=c(1:49), nrow=6, key.loc=c(20,-1),
main="Segment plot of Bumpus' data", draw.segment=TRUE)
# compare to biplot:
windows()
biplot(pca.res, scale=0)
# what do the arrows mean?
# consider the arrow for sternum:
abline(0, pca.res$rotation[5,2]/pca.res$rotation[5,1])
# consider the arrow for head:
abline(0, pca.res$rotation[3,2]/pca.res$rotation[3,1])
bumpus.centered <- data.frame(apply(bumpus, 2, scale, scale=FALSE))
boxplot(bumpus.centered)
# apply PCA:
pca.res.2 <- prcomp(bumpus.centered, retx=TRUE)
pca.res.2
# compare to PCA on standardized data that is scaled back to original scale:
# pca on standardized data:
pca.res
# y1 = 0.451 * total/sd(total) + 0.461 * alar/sd(alar) + ...
# y1 = 0.451/sd(total) * total + 0.461/sd(alar) * alar + ...
# y1 = 0.124 * total + 0.0911 * alar + ...
a <- pca.res$rotation[,1]/apply(bumpus,2,sd)
# scale coefficients by factor c, so that sum of squared coefficients = 1:
c <- sqrt(sum(a^2))
a <- a/c
sum(a^2)
# y1 = 0.113*total + 0.083*alar + 0.517*head + 0.761*humerus + 0.366*sternum
# very different from results in pca.res.2:
# y1* = 0.536*total + 0.829*alar + 0.096*head + 0.074*humerus + 0.100*sternum
# also proportion of the variance explained is different:
summary(pca.res)
summary(pca.res.2)
plot(pca.res)
screeplot(pca.res)
screeplot(pca.res, type="lines")
# check that it simply plots the variances of the principal components:
apply(pca.res$x, 2, var)
# correlation between original variables and principal components
corr <- cor(bumpus.scaled, pca.res$x)
round(corr, 2)
# correlation^2: amount of variation of each of the variables that
# is explained by the principal components:
round(corr^2, 2)
# note the rows sum to 1:
apply(corr^2, 1, sum)
##################
# USJudgeRatings #
##################
pca.res <- prcomp(USJudgeRatings, center=TRUE, retx=TRUE)
pca.res
screeplot(pca.res)
biplot(pca.res, scale=0, xlim=c(-6,9), ylim=c(-6,9))
windows()
plot(pca.res$x[,1:2], xlim=c(-6,9), ylim=c(-6,9), pch="")
text(pca.res$x[,1:2], labels=abbreviate(row.names(USJudgeRatings)), col="blue")
# compare to star plot:
windows()
USJudge <- apply(USJudgeRatings, 2, function(x) x/max(x))
loc <- stars(USJudge, labels = NULL, scale = FALSE,
radius = FALSE, frame.plot = TRUE,
key.loc = c(13, 1.5), main = "Judge data",
len = 1.2)
text(loc, abbreviate(row.names(USJudgeRatings)),
col = "blue", cex = 0.8, xpd = TRUE)
# correlation between original variables and principal components
corr <- cor(USJudgeRatings, pca.res$x)
round(corr, 2)
# correlation^2: amount of variation of each of the variables that
# is explained by the principal components:
round(corr^2, 2)
# note the rows sum to 1:
apply(corr^2, 1, sum)
getwd()
setwd("~/Documents/College/Senior Year/Winter Quarter/Psych 254/psych254_materials/analyses")
subinfo <- read.csv("../data/sklar_expt6_subinfo_corrected.csv")
head(subinfo)
library(ggplot2)
library(dplyr)
library(tidyr)
head(diamonds)
qplot(diamonds$carat, diamonds$price)
ggplot(diamonds, aes(x=carat, y=price)) +
ggtitle("Diamonds by Carat and Price") +
xlab("Diamond Carats") + ylab("Diamond Price") +
geom_point(shape=clarity,
color = cut,
alpha = 0.5)
ggplot(diamonds, aes(x=carat, y=price)) +
ggtitle("Diamonds by Carat and Price") +
xlab("Diamond Carats") + ylab("Diamond Price") +
geom_point(shape=diamonds$clarity,
color = diamonds$cut,
alpha = 0.5)
ggplot(diamonds, aes(x=carat, y=price)) +
ggtitle("Diamonds by Carat and Price") +
xlab("Diamond Carats") + ylab("Diamond Price") +
geom_point(shape=diamonds$clarity,
color = levels(diamonds$cut),
alpha = 0.5)
ggplot(diamonds, aes(x=carat, y=price)) +
ggtitle("Diamonds by Carat and Price") +
xlab("Diamond Carats") + ylab("Diamond Price") +
geom_point(aes(shape=clarity,
color = cut)),
alpha = 0.5)
ggplot(diamonds, aes(x=carat, y=price)) +
ggtitle("Diamonds by Carat and Price") +
xlab("Diamond Carats") + ylab("Diamond Price") +
geom_point(aes(shape=clarity,
color = cut))
subinfo <- read.csv("../data/sklar_expt6_subinfo_corrected.csv")
d.a <- read.csv("../data/sklar_expt6a_corrected.csv")
d.b <- read.csv("../data/sklar_expt6b_corrected.csv")
head(subinfo)
head(d.a)
head(d.b)
subinfo <- tbl_df(subinfo)
d.a <- tbl_df(d.a)
d.b <- tbl_df(d.b)
View(subinfo)
View(d.a)
View(d.b)
install.packages("stringr")
install.packages("stringr")
install.packages("stringr")
install.packages("stringr")
library(stringr)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
library(ggplot2)
ggplot(diamonds, aes(x=carat, y=price)) +
ggtitle("Diamonds by Carat and Price") +
xlab("Diamond Carats") + ylab("Diamond Price") +
geom_point(aes(shape=clarity,
color = cut)) +
facet_grid(clarity ~ cut)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
head(diamonds)
qplot(diamonds$carat, diamonds$price)
